/// <reference types="node" />
import { AxiosInstance } from "axios";
export interface AuthRequest {
    endUserIp: string;
    personalNumber?: string;
    requirement?: AuthOptionalRequirements;
}
export interface AuthResponse {
    autoStartToken: string;
    qrStartSecret: string;
    qrStartToken: string;
    orderRef: string;
}
interface AuthOptionalRequirements {
    cardReader?: "class1" | "class2";
    certificatePolicies?: string[];
    issuerCn?: string[];
    autoStartTokenRequired?: boolean;
    allowFingerprint?: boolean;
}
export interface SignRequest extends AuthRequest {
    userVisibleData: string;
    userNonVisibleData?: string;
}
export interface SignResponse extends AuthResponse {
}
export interface CollectRequest {
    orderRef: string;
}
export interface CollectResponse {
    orderRef: string;
    status: "pending" | "failed" | "complete";
    hintCode?: FailedHintCode | PendingHintCode;
    completionData?: CompletionData;
}
export interface CompletionData {
    user: {
        personalNumber: string;
        name: string;
        givenName: string;
        surname: string;
    };
    device: {
        ipAddress: string;
    };
    cert: {
        notBefore: string;
        notAfter: string;
    };
    signature: string;
    ocspResponse: string;
}
export declare type FailedHintCode = "expiredTransaction" | "certificateErr" | "userCancel" | "cancelled" | "startFailed";
export declare type PendingHintCode = "outstandingTransaction" | "noClient" | "started" | "userSign";
export interface CancelRequest extends CollectRequest {
}
export interface CancelResponse {
}
export interface ErrorResponse {
    errorCode: BankIdErrorCode;
    details: string;
}
export declare enum BankIdErrorCode {
    ALREADY_IN_PROGRESS = "alreadyInProgress",
    INVALID_PARAMETERS = "invalidParameters",
    UNAUTHORIZED = "unauthorized",
    NOT_FOUND = "notFound",
    METHOD_NOT_ALLOWED = "methodNotAllowed",
    REQUEST_TIMEOUT = "requestTimeout",
    UNSUPPORTED_MEDIA_TYPE = "unsupportedMediaType",
    INTERNAL_ERROR = "internalError",
    MAINTENANCE = "maintenance"
}
export declare const REQUEST_FAILED_ERROR = "BANKID_NO_RESPONSE";
export declare enum BankIdMethod {
    auth = "auth",
    sign = "sign",
    collect = "collect",
    cancel = "cancel"
}
export declare type BankIdRequest = AuthRequest | SignRequest | CollectRequest | CancelRequest;
export declare type BankIdResponse = CancelResponse | AuthResponse | SignResponse | CollectResponse;
interface BankIdClientSettings {
    production: boolean;
    refreshInterval?: number;
    pfx?: string | Buffer;
    passphrase?: string;
    ca?: string | Buffer;
}
export declare class BankIdError extends Error {
    readonly code: BankIdErrorCode;
    readonly details?: string;
    constructor(code: BankIdErrorCode, details?: string);
}
export declare class RequestError extends Error {
    readonly request?: any;
    constructor(request?: any);
}
export declare class BankIdClient {
    readonly options: Required<BankIdClientSettings>;
    readonly axios: AxiosInstance;
    readonly baseUrl: string;
    constructor(options?: BankIdClientSettings);
    authenticate(parameters: AuthRequest): Promise<AuthResponse>;
    sign(parameters: SignRequest): Promise<SignResponse>;
    collect(parameters: CollectRequest): Promise<CollectResponse>;
    cancel(parameters: CollectRequest): Promise<CancelResponse>;
    authenticateAndCollect(parameters: AuthRequest): Promise<CollectResponse>;
    signAndCollect(parameters: SignRequest): Promise<CollectResponse>;
    _awaitPendingCollect(orderRef: string): Promise<CollectResponse>;
    _call<Req extends BankIdRequest, Res extends BankIdResponse>(method: BankIdMethod, payload: Req): Promise<Res>;
    _createAxiosInstance(): AxiosInstance;
}
export {};
