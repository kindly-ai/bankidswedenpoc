"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BankIdClient = exports.RequestError = exports.BankIdError = exports.BankIdMethod = exports.REQUEST_FAILED_ERROR = exports.BankIdErrorCode = void 0;
const fs = require("fs");
const https = require("https");
const path = require("path");
const axios_1 = require("axios");
var BankIdErrorCode;
(function (BankIdErrorCode) {
    BankIdErrorCode["ALREADY_IN_PROGRESS"] = "alreadyInProgress";
    BankIdErrorCode["INVALID_PARAMETERS"] = "invalidParameters";
    BankIdErrorCode["UNAUTHORIZED"] = "unauthorized";
    BankIdErrorCode["NOT_FOUND"] = "notFound";
    BankIdErrorCode["METHOD_NOT_ALLOWED"] = "methodNotAllowed";
    BankIdErrorCode["REQUEST_TIMEOUT"] = "requestTimeout";
    BankIdErrorCode["UNSUPPORTED_MEDIA_TYPE"] = "unsupportedMediaType";
    BankIdErrorCode["INTERNAL_ERROR"] = "internalError";
    BankIdErrorCode["MAINTENANCE"] = "maintenance";
})(BankIdErrorCode = exports.BankIdErrorCode || (exports.BankIdErrorCode = {}));
exports.REQUEST_FAILED_ERROR = "BANKID_NO_RESPONSE";
//
// Collection of overarching types
//
var BankIdMethod;
(function (BankIdMethod) {
    BankIdMethod["auth"] = "auth";
    BankIdMethod["sign"] = "sign";
    BankIdMethod["collect"] = "collect";
    BankIdMethod["cancel"] = "cancel";
})(BankIdMethod = exports.BankIdMethod || (exports.BankIdMethod = {}));
//
// Error types
//
class BankIdError extends Error {
    constructor(code, details) {
        super(code);
        Error.captureStackTrace(this, this.constructor);
        this.name = "BankIdError";
        this.code = code;
        this.details = details;
    }
}
exports.BankIdError = BankIdError;
class RequestError extends Error {
    constructor(request) {
        super(exports.REQUEST_FAILED_ERROR);
        Error.captureStackTrace(this, this.constructor);
        this.name = "RequestError";
        this.request = request;
    }
}
exports.RequestError = RequestError;
//
// Client implementation
//
class BankIdClient {
    constructor(options) {
        this.options = {
            production: false,
            refreshInterval: 2000,
            // defaults for test environment
            passphrase: "qwerty123",
            pfx: path.resolve(__dirname, "../cert/", "FPTestcert3_20200618.p12"),
            ...options,
        };
        if (this.options.production) {
            if (!(options === null || options === void 0 ? void 0 : options.pfx) || !(options === null || options === void 0 ? void 0 : options.passphrase)) {
                throw Error("BankId requires the pfx and passphrase in production mode");
            }
        }
        // Provide certificate by default
        if (this.options.ca === undefined) {
            this.options.ca = this.options.production
                ? path.resolve(__dirname, "../cert/", "prod.ca")
                : path.resolve(__dirname, "../cert/", "test.ca");
        }
        this.axios = this._createAxiosInstance();
        this.baseUrl = this.options.production
            ? "https://appapi2.bankid.com/rp/v5.1/"
            : "https://appapi2.test.bankid.com/rp/v5.1/";
    }
    authenticate(parameters) {
        if (!parameters.endUserIp) {
            throw Error("Missing required argument endUserIp.");
        }
        return this._call(BankIdMethod.auth, parameters);
    }
    sign(parameters) {
        if (!parameters.endUserIp || !parameters.userVisibleData) {
            throw Error("Missing required arguments: endUserIp, userVisibleData.");
        }
        parameters = {
            ...parameters,
            userVisibleData: Buffer.from(parameters.userVisibleData).toString("base64"),
            userNonVisibleData: parameters.userNonVisibleData
                ? Buffer.from(parameters.userNonVisibleData).toString("base64")
                : undefined,
        };
        return this._call(BankIdMethod.sign, parameters);
    }
    collect(parameters) {
        return this._call(BankIdMethod.collect, parameters);
    }
    cancel(parameters) {
        return this._call(BankIdMethod.cancel, parameters);
    }
    async authenticateAndCollect(parameters) {
        const authResponse = await this.authenticate(parameters);
        return this._awaitPendingCollect(authResponse.orderRef);
    }
    async signAndCollect(parameters) {
        const signResponse = await this.sign(parameters);
        return this._awaitPendingCollect(signResponse.orderRef);
    }
    _awaitPendingCollect(orderRef) {
        return new Promise((resolve, reject) => {
            const timer = setInterval(() => {
                this.collect({ orderRef })
                    .then(response => {
                    if (response.status === "complete") {
                        clearInterval(timer);
                        resolve(response);
                    }
                    else if (response.status === "failed") {
                        clearInterval(timer);
                        reject(response);
                    }
                })
                    .catch(error => {
                    clearInterval(timer);
                    reject(error);
                });
            }, this.options.refreshInterval);
        });
    }
    _call(method, payload) {
        return new Promise((resolve, reject) => {
            this.axios
                .post(this.baseUrl + method, payload)
                .then(response => {
                resolve(response.data);
            })
                .catch((error) => {
                let thrownError;
                if (error.response) {
                    console.log(error.response.data.errorCode);
                    thrownError = new BankIdError(error.response.data.errorCode, error.response.data.details);
                }
                else if (error.request) {
                    thrownError = new RequestError(error.request);
                }
                else {
                    thrownError = error;
                }
                reject(thrownError);
            });
        });
    }
    _createAxiosInstance() {
        const ca = Buffer.isBuffer(this.options.ca)
            ? this.options.ca
            : fs.readFileSync(this.options.ca, "utf-8");
        const pfx = Buffer.isBuffer(this.options.pfx)
            ? this.options.pfx
            : fs.readFileSync(this.options.pfx);
        const passphrase = this.options.passphrase;
        return axios_1.default.create({
            httpsAgent: new https.Agent({ pfx, passphrase, ca }),
            headers: {
                "Content-Type": "application/json",
            },
        });
    }
}
exports.BankIdClient = BankIdClient;
//# sourceMappingURL=bankid.js.map